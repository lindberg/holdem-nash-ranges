# Regret-based system to reach Nash equilibrium  
## Introduction
A regret-based system is a way for a system to learn the appropriate action in a given situation based on the amount of regret that was given the last time the system chose the same action in the same or a similar situation. This is similar to how humans attain intuition.
Our task was to create a regret-based system that attempts to reach Nash equilibrium for push/fold heads-up no-limit hold’em when the effective stack is 10 big blinds. To do this we needed two things:

* A regret-based system that over millions of hands learns the decision with most expected value in any given situation.
* A hand evaluator so we know which player won every specific hand.

We will check our results against other Nash equilibrium charts generated by different sources.
## Hand evaluator
With TwoPlusTwo hand evaluator, we can evaluate the strength of 7 given cards. The strength is represented as a number. When the number is higher, the hand is better. By comparing this number with the number strength of another 7 cards, we know which hand won.
Every card is represented by an integer 1-52:


![card table](img/table.png)

*Note: The order of the suits does not matter as long as it is consistent.*

## Regret-based system
For this we needed:

* A way to store a regret tree.
* A way of cycling through millions of hands trying all possible different actions for every hand and updating the regret system accordingly.

### Regret tree
![regret tree](img/tree.png)

*Figure 1: A very simplified version of the regret tree only considering the hand AA.*

In Figure 1 we can see how the regret tree is built in a simplified way. The actual regret tree looks the same but have 169 times as many regret nodes since there are 169 different starting hands in Texas Hold ‘em and the simplified tree only considers one of them. This means that the actual regret tree consists of 169 * 4 = 676 regret nodes.

Note: There are actually 1 326 combinations of possible starting hands, but only 169 matter since for example Tc9c from a preflop perspective can be viewed the same as Th9h, so we group these and the two other suits of tens and nines and call them T9s.

We needed a way to accurately give regret based on the result of an action. We could not just give +1 or -1 regret if the action turned out good or bad since the small blind and the big blind get different amounts of profit if push or call works out. Therefore, we gave regret in amount of profit or loss in small blinds that the action resulted in. A positive profit means a positive regret and a loss means a negative regret.

### Storage issues
In this particular case with only 676 regret nodes, we didn’t have to worry about storage or memory issues. However, if we want to make a more complicated system this might be an issue. If we used only one byte as a regret node, we would have a regret value ranging from -128 to 127. One successful push from the small blind would increase the regret value with 21 since 19 small blinds were used for the push and 40 small blinds were won, therefore a profit of 21 small blinds. Already, we would have used up more than 16 % of the limit of positive regret. This could create problems with variance since we are simulating millions of hands and the regret caps before the system can come to a valid conclusion of what the right action is in the specific spot.

Instead, if we use two bytes as the size for a regret node, one successful push would use up more than 0.06 % of the limit of positive regret. This might work for this problem, since it takes 1561 successful pushes to cap the regret node and it seems intuitively unreasonable that variance could bring this to below zero again after it is capped. For larger problems than this, with for example 200 small blinds in play, only 163 successful pushes from the small blind are needed to cap the regret node. This is a significantly different number than 1 561. We see that higher stack sizes require more regret node storage in order for the system to perform as good.

With all of that said, for this simple problem we used 4 bytes to really make sure that variance would never be a problem. In total, the regret file took up 2 704 bytes of space.

### File structure
We created a program that generated a regret.dat file. We dedicated half of the file for the small blind and half of the file for the big blind. More specifically, the first 1 352 bytes were dedicated to the small blind and the next 1 352 bytes were dedicated to the big blind. We then paired every starting hand with two actions: either push/fold from the small blind or call/fold from the big blind. Every pair takes up 4 * 2 = 8 bytes. The order of hands start with all the pairs 22-AA, then cycles through all the offsuited combinations 32o-A2o, 43o-A3o, …, KQo-AQo, AKo and finally cycle through the suited combinations in the same way.

![preflop hands](img/preflop_hands.png)

*Figure 2: Table of all starting hands (image source: PokerStove).*

If we for example want to find the regret for the big blind folding to T5s we take the following steps:
1. Skip forward half the file, that is 1 352 bytes.
2. Skip forward all the 13 pairs, which is 13 * 8 = 104 bytes.
3. Skip forward all the offsuited combinations, which is 78 * 8 = 624 bytes.
4. Skip forward all the suited combinations before T5s, which is 37 * 8 = 296 bytes.
5. Skip forward 4 bytes to get from call regret to fold regret.
6. The following 4 bytes is the fold regret for T5s as the big blind.

Adding these numbers up, we conclude that we need to skip the first 2 380 bytes in the regret file and read bytes 2 381 to 2 384. Converting these bytes into an integer will get us the regret for this action. In the actual program, the regret tree is first represented as a file and then stored in memory as an array of integers. The process of finding the right index to this array is done by RegretTree’s RegretIndex function.

## Regret system
We said earlier that only 169 hands matter for this problem. In actuality, we need to make sure that we do not match for example the same T9s against the same 56o every time, since there are three possible matchups here:
* 56o does not share any suit with T9s.
* The five in 56o is the same suit as T9s.
* The six in 56o is the same suit as T9s.

These three matchups will play slightly different against each other. An easy way to solve this is to pick completely random cards from a deck and converting them to one of the 169 hands afterwards.
